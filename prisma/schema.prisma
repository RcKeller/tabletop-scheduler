generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum MeetingType {
  DISCORD
  ZOOM
  GOOGLE_MEET
  ROLL20
  FOUNDRY_VTT
  IN_PERSON
  OTHER
}

enum CampaignType {
  ONESHOT
  CAMPAIGN
}

// New availability system enums
enum AvailabilityRuleType {
  available_pattern   // Recurring weekly availability
  available_override  // One-off date availability
  blocked_pattern     // Recurring weekly block
  blocked_override    // One-off date block
}

enum RuleSource {
  manual
  ai
  import
}

model GameSystem {
  id                  String   @id @default(uuid())
  name                String   @unique
  description         String?
  imageBase64         String?  @db.Text
  defaultInstructions String?  @db.Text
  defaultUrls         Json?    // Array of { label: string, url: string }
  isBuiltIn           Boolean  @default(false)
  createdAt           DateTime @default(now())
  events              Event[]

  @@map("game_systems")
}

model Event {
  id                String        @id @default(uuid())
  slug              String        @unique
  title             String
  description       String?
  timezone          String        @default("UTC")
  createdAt         DateTime      @default(now())
  participants      Participant[]

  // Campaign type (oneshot vs campaign)
  campaignType                   CampaignType @default(CAMPAIGN)

  // Game system relationship
  gameSystemId               String?
  gameSystem                 GameSystem? @relation(fields: [gameSystemId], references: [id], onDelete: SetNull)

  // Campaign configuration
  campaignImageBase64        String?     @db.Text
  sessionLengthMinutes       Int         @default(180)
  customPreSessionInstructions String?   @db.Text
  playerPrepUrls             Json?       // Array of { label: string, url: string }
  requireCharacterCreation   Boolean     @default(false)

  // Date range for availability window
  startDate                  DateTime?   @db.Date
  endDate                    DateTime?   @db.Date

  // Daily time window (stored in event timezone)
  earliestTime               String      @default("00:00")
  latestTime                 String      @default("23:30")

  // Meeting configuration
  meetingType                MeetingType?
  meetingLocation            String?
  meetingRoom                String?

  // Player count limits
  minPlayers                 Int?
  maxPlayers                 Int?

  // Legacy fields (kept for backward compatibility)
  isRecurring                Boolean     @default(false)
  recurrencePattern          Json?
  startTime                  DateTime?
  durationMinutes            Int?

  @@map("events")
}

model Participant {
  id                    String                 @id @default(uuid())
  eventId               String
  event                 Event                  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  displayName           String
  isGm                  Boolean                @default(false)
  timezone              String                 @default("UTC")
  characterName         String?
  characterClass        String?
  characterSheetUrl     String?
  characterTokenBase64  String?                @db.Text
  notes                 String?                @db.VarChar(255)
  createdAt             DateTime               @default(now())

  // Availability rules system
  availabilityRules     AvailabilityRule[]

  @@unique([eventId, displayName])
  @@map("participants")
}

model Feedback {
  id          String   @id @default(uuid())
  name        String
  email       String?
  type        String   @default("bug") // "bug" or "feature"
  description String   @db.Text
  createdAt   DateTime @default(now())

  @@map("feedback")
}

// New unified availability rules system
// Replaces Availability, GeneralAvailability, and AvailabilityException tables
model AvailabilityRule {
  id            String                @id @default(uuid())
  participantId String
  participant   Participant           @relation(fields: [participantId], references: [id], onDelete: Cascade)

  // Rule type discriminator
  ruleType      AvailabilityRuleType

  // For patterns: day of week in UTC (0=Sunday, 6=Saturday)
  // For overrides: null
  dayOfWeek     Int?

  // For overrides: specific date in UTC
  // For patterns: null
  specificDate  DateTime?             @db.Date

  // Time range in UTC (HH:MM format)
  startTime     String
  endTime       String

  // Preserve user intent for cross-timezone display
  originalTimezone   String           // IANA timezone (e.g., "Asia/Tokyo")
  originalDayOfWeek  Int?             // What day the user selected in their timezone

  // Metadata
  reason        String?
  source        RuleSource            @default(manual)

  // Audit
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  // Indexes for efficient queries
  @@index([participantId])
  @@index([ruleType])
  @@index([specificDate])
  @@index([dayOfWeek])
  @@map("availability_rules")
}
